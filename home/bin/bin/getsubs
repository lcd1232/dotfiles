#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "yt-dlp[default,curl-cffi]>=2024.0.0",
#     "webvtt-py>=0.5.0",
# ]
# ///

import argparse
import os
import re
import sys
import tempfile
from typing import Iterable, Optional

import webvtt
from yt_dlp import YoutubeDL
from yt_dlp.networking.impersonate import ImpersonateTarget


def get_vtt(url: str, subtitle_type: str, lang: str) -> Optional[str]:
    """
    Download VTT subtitles using yt-dlp library.

    Args:
        url: Video URL
        subtitle_type: Either "subtitles" for manual or "automatic_captions" for auto-generated
        lang: Language code
    """
    temp_dir = tempfile.mkdtemp()

    try:
        ydl_opts = {
            "skip_download": True,
            "writesubtitles": subtitle_type == "subtitles",
            "writeautomaticsub": subtitle_type == "automatic_captions",
            "subtitleslangs": [lang],
            "subtitlesformat": "vtt",
            "outtmpl": os.path.join(temp_dir, "%(id)s.%(ext)s"),
            "quiet": True,
            "no_warnings": True,
            "impersonate": ImpersonateTarget("chrome"),
        }

        with YoutubeDL(ydl_opts) as ydl:
            try:
                ydl.download([url])
            except Exception:
                return None

        # Find and read the .vtt file
        for filename in os.listdir(temp_dir):
            if filename.endswith(".vtt"):
                vtt_path = os.path.join(temp_dir, filename)
                with open(vtt_path, "r", encoding="utf-8") as f:
                    return f.read()

        return None
    finally:
        import shutil

        shutil.rmtree(temp_dir, ignore_errors=True)


def remove_consecutive_duplicates(items: list[str]) -> Iterable[str]:
    """Remove consecutive duplicate items from a list."""
    previous = None
    for item in items:
        if item != previous:
            yield item
        previous = item


def vtt_lines(vtt_content: str) -> Iterable[str]:
    """
    Convert a VTT string to a list of lines.

    YouTube's subtitles have some weirdnesses which this function tries to
    handle. It probably doesn't do it perfectly.
    """
    # Write VTT content to a temporary file since webvtt-py reads from files
    with tempfile.NamedTemporaryFile(mode="w", suffix=".vtt", delete=False) as f:
        f.write(vtt_content)
        temp_path = f.name

    try:
        vtt_data = webvtt.read(temp_path)

        raw_lines = []
        for caption in vtt_data:
            text = caption.text.strip()
            if text:
                # Remove multiple spaces and semicolons pattern
                text = re.sub(r"(?:\s+;)*", "", text)
                raw_lines.append(text)

        # Split by newlines and filter empty lines
        all_lines = []
        for line in raw_lines:
            for subline in line.split("\n"):
                subline = subline.strip()
                if subline:
                    all_lines.append(subline)

        return remove_consecutive_duplicates(all_lines)
    finally:
        os.unlink(temp_path)


def get_available_subtitles(url: str) -> dict[str, list[str]]:
    """
    Get available subtitle languages for a URL.

    Returns:
        Dictionary with 'manual' and 'auto' keys containing language lists
    """
    ydl_opts = {
        "skip_download": True,
        "quiet": True,
        "no_warnings": True,
    }

    try:
        with YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)

            manual_subs = list(info.get("subtitles", {}).keys())
            auto_subs = list(info.get("automatic_captions", {}).keys())

            return {
                "manual": manual_subs,
                "auto": auto_subs,
            }
    except Exception as e:
        print(f"error: failed to fetch video info: {e}", file=sys.stderr)
        return {"manual": [], "auto": []}


def main() -> None:
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Download and extract YouTube subtitles"
    )
    parser.add_argument("url", help="Video URL")
    parser.add_argument(
        "--lang",
        default="en",
        help="Subtitle language code (default: en)",
    )

    args = parser.parse_args()

    url = args.url
    lang = args.lang

    available = get_available_subtitles(url)
    all_langs = set(available["manual"] + available["auto"])

    if not all_langs:
        print("error: could not fetch available subtitles", file=sys.stderr)
        sys.exit(1)

    if lang not in all_langs:
        print(
            f"error: subtitles not available for language '{lang}'",
            file=sys.stderr,
        )
        print(f"available languages: {', '.join(sorted(all_langs))}", file=sys.stderr)
        sys.exit(1)

    # Try manual subtitles first, then auto-generated
    vtt_content = None
    if lang in available["manual"]:
        vtt_content = get_vtt(url, "subtitles", lang)

    if not vtt_content and lang in available["auto"]:
        vtt_content = get_vtt(url, "automatic_captions", lang)

    if not vtt_content:
        print("no subs found", file=sys.stderr)
        sys.exit(1)

    for line in vtt_lines(vtt_content):
        print(line)


if __name__ == "__main__":
    main()
